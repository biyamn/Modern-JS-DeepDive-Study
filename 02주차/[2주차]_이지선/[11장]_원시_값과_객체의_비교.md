# [11장] 원시 값과 객체의 비교

- 원시 값은 변경 불가능한 값. 객체(참조)는 변경 가능한 값
- 원시 값은 값에 의한 전달, 객체는 참조에 의한 전달을 한다.
- 원시 값을 변수에 할당하면 메모리에 실제 값이 저장되지만 객체는 참조 값이 저장된다.

# 원시값

### 불변성

원시 값 자체는 변경 할 수 없다

- ‘변경할 수 없다’? → 원시 값을 할당한 변수에 새로운 원시 값을 재할당하면 그 원시값이 바뀌는게 아니라 새로운 원시값을 새로운 메모리 공간에 확보하고 변수는 새롭게 재할당한 원시값을 가리킨다. 그렇게 변수가 참조하던 **메모리 공간의 주소**가 바뀐다.
- 원시값은 변경 불가능한 값이라서 값을 직접 변경할 수 없다. 이러한 특성을 **‘불변성’**이라고 한다.

### 값에 의한 전달

아래에서 score 변수와 copy 변수의 값은 다른 메모리 공간에 저장된 별개의 값이다.(원시 값은 메모리에 실제 값이 저장되고 이는 변경 불가능함) 그래서 score 변수의 값을 변경해도 copy 변수의 값에는 영향을 주지 않는다. 결국 두 변수의 원시값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느쪽에서 재할당을 하더라도 서로 간섭할 수 없다.

```tsx
let score = 80;

let copy = score;

console.log(score, copy); // 80, 80

score = 100;

console.log(score, copy); // 100, 80
```

# 객체

객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해둘 수 없다(프로퍼티의 개수가 정해져있지 않고 동적으로 추가되고 삭제할 수 있으며 값에도 제한이 없음 아주아주 크게 만들 수 있다는 뜻) → 그래서 원시값에 비교하여 비용이 많이 든다. → 객체는 원시 값과는 다른 방식으로 동작하도록 설계되었다.

<aside>

**크롬 V8엔진이 객체를 관리하는 법**

Fast properties in V8: https://v8.dev/blog/fast-properties
■ V8 히든 클래스 이야기: https://engineering.linecorp.com/ko/blog/v8-hidden-class,
■ 자바스크립트 엔진의 최적화 기법 (2) - Hidden class, Inline Caching: https://meetup.toast.com/posts/78
■ How the V8 engine works?: http://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-wo

</aside>

### 변경 가능한 값

객체(참조) 타입의 값, 객체는 변경 가능한 값이다. 객체를 할당한 변수에는 원시 값이 아니라 객체가 실제로 저장된 메모리 공간의 주소가 저장되어 있다. 변수는 이 참조 값을 통해 객체에 접근한다.

- 원시 값과 다른 점
  - 원시 값
    - 원시 값을 할당한 변수를 참조하면 메모리에 저장되어 있는 원시 값에 접근
    - 변수의 값을 변경하려면 재할당 외에는 방법이 없음
  - 객체
    - 객체를 할당한 변수를 참조하면 메모리에 저장되어 있는 참조 값을 통해 실제 객체에 접근
    - 재할당 없이 객체 직접 변경 가능

### 단점: 여러 개의 식별자가 하나의 객체를 공유 가능!!!(원시 값과 다르게) → 얕은 복사와 깊은 복사

- 얕은 복사: 한 단계까지만 복사
- 깊은 복사: 객체에 중첩된 객체까지 모두 복사

**(발표: [11장/원시 값과 객체의 비교] 얕은 복사와 깊은 복사의 차이를 코드를 사용해 설명하시오.(이지선))**

https://gist.github.com/biyamn/7015632fe24ff91daea32358d07b2236

### 참조에 의한 전달

- 원본 또는 사본 중 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.
