# :fire: 25장. 클래스

- ES6에 새로 도입. 새로운 객체 생성 매커니즘.

## :one: 클래스의 정의

- 클래스는 일급객체이다.
- 0개 이상의 메서드만 정의할 수 있다. constructor, 프로토타입 메서드, 정적 메서드

---

## :two: 클래스 호이스팅

- 클래스 선언문으로 정의한 클래스는 소스코드 평가 과정(런타임 이전)에 평가되어 함수 객체를 생성한다. (constructor)
- 클래스는 클래스 정의 이전에 참조할 수 없다. 호이스팅은 발생하나 TDZ에 빠지기 때문.

---

## :three: 인스턴스 생성

- 클래스는 생성자 함수이며 new 연산자와 함께 호출되어 인스턴스를 생성한다.
- 기명 함수 표현식과 마찬가지로 클래스 표현식에서 사용한 클래스 이름은 외부 코드에서 접근 불가능하다.

---

## :four: 메서드

- 클래스는 생성자 함수이며 new 연산자와 함께 호출되어 인스턴스를 생성한다.
- 기명 함수 표현식과 마찬가지로 클래스 표현식에서 사용한 클래스 이름은 외부 코드에서 접근 불가능하다.

### 📖 constructor

- 인스턴스를 생성하고 초기화하기 위한 특수한 메서드.
- 이름 변경 불가.
- constructor 내부에서 this에 추가한 프로퍼티는 인스턴스 프로퍼티가 된다.
- constructor는 메서드로 해석되는 것이 아니라 클래스가 평가되어 생성한 함수 객체 코드의 일부가 된다.
- constructor는 2개 이상 존재할 수 없으며, 생략 가능하다.
- 인스턴스 생성할 때 클래스 외부에서 인스턴스 프로퍼티 초기값을 전달하려면 constructor에 매개변수를 선언하고 인스턴스를 생성할 때 초기값을 전달한다.
- 별도의 반환문을 갖지 않는다.

### 📖 프로토타입 메서드

- 클래스 몸체에서 정의한 메서드는 생성자 함수에 의한 객체 생성방식과는 다르게, 클래스의 프로토타입 프로퍼티에 메서드를 추가하지 않아도 기본적으로 프로토타입 메서드가 된다.

### 📖 정적 메서드

- 정적 메서드: 인스턴스를 생성하지 않아도 호출할 수 있는 메서드.
- 클래스에서는 메서드에 static 키워드를 붙이면 정적 메서드가 된다.

### 📖 정적 메서드와 프로토타입 메서드의 차이

- 자신이 속한 프로토타입 체인
- 정적 메서드는 클래스로 호출하고 프로토타입 메서드는 인스턴스로 호출한다.
- 정적 메서드는 인스턴스 프로퍼티를 참조할 수 없지만 프로토타입 메서드는 인스턴스 프로퍼티를 참조할 수 있다.
- 정적 메서드의 this는 클래스. 프로토타입 메서드의 this는 메서드를 호출한 인스턴스.

### 📖 클래스에서 정의한 메서드의 특징

- function 키워드를 생략한 메서드 축약 표현을 하용한다.
- 콤마가 필요 없다.
- 암묵적으로 strict mode로 실행된다.
- for in 문이나 Object.keys 메서드 등으로 열가할 수 없다. (프로퍼티 어트리뷰트[[Enumerable]]값이 false다.
- non-constructor.

---

## :five: 클래스의 인스턴스 생성과정

1. new 연산자와 함께 클래스를 호출하면 빈 객체 생성. 인스턴스는 this에 바인딩된다.
2. constructor 내부 코드가 실행되며 인스턴스 초기화 된다.
3. 클래스의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.

---

## :six: 프로퍼티

### 📖 인스턴스 프로퍼티

- 인스턴스 프로퍼티는 constructor 내부에서 정의한다.
- 자바스크립트의 클래스에서는 접근 제한자(private, public, protected)를 지원하지 않기 때문에, 인스턴스 프로퍼티는 언제나 public하다.

### 📖 접근자 프로퍼티

- 접근자 프로퍼티는 자체적으로 값을 갖지 않고, 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수로 구성된 프로퍼티다.(getter, setter)

```javascript
class Person {
  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }
  get fullName(){
    return `${this.firstName} ${this.lastName}`;  
  }
  set fullName(name){
    [this.firstName, this.lastName] = name.split(' ');
  }
}
const me = new Person('Ungmo','Lee');
me.fullName = 'Heegen Lee';
console.log(me); // {firstName:"Heegun", lastName:"Lee"}
console.log(me.fullName); // Heegen Lee
```

### 📖 클래스 필드 정의 제안

- **클래스 필드**: 클래스 기반 객체지향 언어에서 클래스가 생성할 인스턴스의 프로퍼티를 가리키는 용어
- 인스턴스 프로퍼티를 선언, 초기화, 참조할 때 반드시 this를 사용해야 한다.
- 클래스의 this는 주로 클래스 필드가 생성자 또는 메서드의 매개변수 이름과 동일할 때, 클래스 필드임을 명확하게 하기 위해 사용한다.
- 자바스크립트의 클래스 몸체에는 메서드만 선언할 수 있으나, Node.js에서 실행하면 정상동작한다.
- 클래스 필드를 통해 메서드를 정의할 수도 있다.

### 📖 private 필드 정의 제안

- ES6에서는 지원하고 있지 않으나, Node.js에서는 이미 구현되어있다.
- private 필드의 선두에는 #을 붙여준다. 참조할 때도 #을 붙여주어야한다.
- private 필드에는 직접 접근할 수 없으나, 접근자 프로퍼티를 통해 간접적으로 접근하는 방법은 유효하다.
- private 필드를 직접 constructor에 정의하면 SystaxError 발생한다ㅣ private 필드는 반드시 클래스 몸체에 정의해야 한다.

---

## :seven: 상속에 의한 클래스 확장

- 프로토타입 기반 상속과는 달리, 상속에 의한 클래스 확장은 새로운 클래스를 확장하여 정의하는 것이다. 클래스는 상속을 통해 기존 클래스를 확장할 수 있는 문법이 기본적으로 제공된다(extends).

### 📖 extends 키워드

- 상속을 통해 확장된 클래스를 서브 클래스, 서브클래스에게 상속한 클래스를 수퍼 클래스라 부른다.
- 수퍼클래스와 서브 클래스는 클래스 간의 프로토타입 체인도 생성하여, 이를 통해 프로토타입 메서드, 정적 메서드 모두 상속이 가능하다.

### 📖 동적 상속

- extends 키워드로 클래스 뿐만 아니라 생성자 함수를 상속받아 클래스를 확장할 수 있다. 이 경우 extends 키워드 앞에 class 키워드가 붙어야한다.

### 📖 서브클래스의 constructor

- 서브클래스에서 constructor를 생략하면, 클래스에 다음과 같은 constructor가 암묵적으로 정의된다.
```
constructor(...args) {super(...args);}
```
- super는 수퍼클래서의 constructor를 호출한다.

### 📖 super 키워드

- super를 호출하면 수퍼클래스의 constructor를 호출한다.
- super를 참조하면 수퍼클래스의 메서드를 호출할 수 있다.
- 서브클래스에서 constructor를 생략하지 않는 경우, 서브클래스의 constructor에는 반드시 super를 호출해야한다.
- 메서드에서 super를 참조하면 수퍼클래스의 메서드를 호출할 수 있다.

### 📖 표준 빌트인 생성자 함수 확장

- 클래스 확장 extends 키워드를 사용하여 표준 빌트인 생성자 함수의 기능을 확장할 수 있다.
