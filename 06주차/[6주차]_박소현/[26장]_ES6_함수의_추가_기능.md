# :fire: 26장. ES6 함수의 추가 기능

- ES6 이전까지 함수는 사용 목적에 따라 명확히 구분되지 않았다. 같은 함수를 일반 함수로 호출할 수도 있고, 생성자 함수로 호출할 수도 있었다. (모두 프로토타입 객체를 생성)
- 실수 유발, 성능 저하
- 이 문제를 해결하기 위해 함수를 사용목적에 따라 다음 세 가지 종류로 구분했다.

|ES6 함수의 구분|constructor|prototype|super|arguments|
|:------------:|-----------|---------|-----|---------|
|일반 함수|o|o|x|o|
|메서드|x|x|o|o|
|화살표 함수|x|x|x|x|

## :one: 메서드

- 메서드 축약 표현으로 정의된 함수

```javascript
const obj = {
  x: 1, 
  foo() {return this.x},
  bar: function() {return this.x;}
}

//여기서 foo()는 메서드이고, bar는 아니다.
```

- 자신을 바인딩한 객체를 가리키는 내부 슬롯[[HomeObject]]을 갖는다. 따라서, super 키워드를 사용할 수 있다. 메서드가 아닌 함수는 super 키워드 사용이 불가하다.

---

## :two: 화살표 함수

- function 키워드 대신 화살표를 사용하여 기존의 함수 정의 방식보다 간략하게 정의. 동작도 간략하다.
- 콜백 함수로서 정의할 때 유용하다.

### 📖 화살표 함수와 일반 함수 차이

- 화살표 함수는 프로토타입 프로퍼티가 없다. 인스턴스 생성 불가.
- 화살표 함수는 중복된 매개변수 이름을 선언할 수 없다.
- 화살표 함수는 함수 자체의 this, arguments, super, new.target 바인딩을 갖지 않는다. 따라서, 화살표 함수 내부에서 이를 참조하면 스코프 체인을 통해 상위 스코프의 this, argemnts, super, new.target을 참조한다.

### 📖 this

- 일반 함수로서 호출되는 모든 함수 내부의 this는 전역 객체를 가리킨다. 클래스 내부의 모든 코드는 strict mode가 암묵적으로 적용되는데, 이 때는 undefined가 바인딩 된다.
- 화살표 함수의 this는 함수 자체의 바인딩을 갖지 않는다. 상위 스코프의 this를 그대로 참조한다(lexical this).

### 📖 super

- 화살표 함수의 super는 함수 자체의 바인딩을 갖지 않는다. 상위 스코프의 super를 그대로 참조한다.

### 📖 arguments

- 화살표 함수의 arguments는 함수 자체의 바인딩을 갖지 않는다. 상위 스코프의 arguments를 그대로 참조한다.

---

## :three: Rest 파라미터

- 화살표 함수로 가변 인자 함수를 구현해야할 때 반드시 Rest 파라미터를 사용해야한다. arguments 객체를 사용할 수 없기 때문.
- 나머지 매개변수라고도 부른다. 매개변수 이름 앞에 세개의 점 ...을 붙여서 정의한 매개변수. Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받는다.
- 일반 매개변수와 Rest 파라미터는 함께 사용할 수 있는데, Rest 파라미터는 맨끝에 배치한다.
- rest 파라미터는 arguments 객체와는 달리 인수 목록을 배열로 직접 전달 받을 수 있어 편하다.

---

## :four: 매개변수 기본값

- 매개변수에 인수가 전달되었는지 확인하여 인수가 전달되지 않은 경우 매개변수에 기본값을 할당할 필요가 있다(방어 코드).
- 또는, 매개변수 기본값을 사용할 수 있다.
